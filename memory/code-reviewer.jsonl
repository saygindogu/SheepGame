{"timestamp":"2026-02-18","session":"wolf-predator-review","files_reviewed":["model/Wolf.java","SheepGame.java","ui/SheepHungerPanel.java"],"verdict":"mostly_correct","bugs":["SheepHungerPanel warning threshold 150px fires after wolf detection radius 175px (difficulty 1)","@Getter class annotation on Wolf generates dead getXLocation()/getYLocation() alongside manual getLocationX()/getLocationY()","getDrawables() snapshot size vs iteration safe only because EDT-only but undocumented"],"medium_issues":["wolves field not initialized until initilize() but physicsTimer lambda captures it by reference before that call","random = new Random() inside createNewObject() re-seeds on every call","tick(int,int) loses double precision of sheep position"],"low_issues":["isGameOver() has timer-stopping side-effect inside a predicate method","difficultyLevel clamped after new Sheep() receives raw value","Wolf constructor references SheepGame.GAME_SIZE_* from model layer (pre-existing project pattern)"],"positives":["No new Timer introduced – wolf ticked in existing physicsTimer","Full EDT safety – no background threads","Hysteresis on ROAMING/CHASING transition","g2.dispose() always called","LocatableShape.overlaps() reused for wolf-sheep collision","returnToMenu() stops both timers cleanly"],"recurring_patterns":["Class-level @Getter + manual getLocationX()/getLocationY() seen in both Sheep and Wolf – project-wide convention but generates dead Lombok getters","SheepGame constants referenced from model classes (pre-existing coupling)","isGameOver() side-effect design pre-dates this PR"]}
{"timestamp":"2026-02-18","session":"stamina-and-rest-review","files_reviewed":["model/RestingSpot.java","model/Sheep.java","SheepGame.java","ui/SheepHungerPanel.java"],"verdict":"mostly_correct","bugs":["fatigueScale multiplies idle recovery making recovery FASTER at higher difficulty — should divide by fatigueScale in the recovery branch (Sheep.java line 231)"],"medium_issues":["fatigueScale applied to FATIGUE_RECOVERY_IDLE in wrong direction"],"low_issues":["createNewObject() does not call isOverlapingRestingSpots() — food/water can spawn on rest spots during gameplay","restPower=2.0 is not difficulty-scaled despite count and size being scaled","shared attempt budget restCount*20 across all spot placements may silently produce fewer spots than restCount","double fatigue recovery (tick idle path + rest() call) when sheep is idle on a rest spot — undocumented interaction"],"positives":["restingSpots never removed in checkCollisions()","draw order correct: restingSpots at index 0 drawn first/underneath","no new javax.swing.Timer introduced","full EDT safety maintained","no ConcurrentModificationException risk — restingSpots and wolves loops are read-only for-each; otherObjects uses Iterator","overlap check for rest spot placement checks both otherObjects AND restingSpots via isOverlapingRestingSpots()","SheepHungerPanel GridLayout(1,3) correctly handles 3 bars","static final Color constants in RestingSpot","g2.dispose() called in RestingSpot.draw()","effectiveMaxSpeed only caps velocity not acceleration — fatigue does not degrade responsiveness","fatigue clamped to [0,MAX_FATIGUE] after every tick","Sheep.rest() uses Math.max(0.0,...) consistent with eat()/drink() pattern","RestingSpot @Getter generates no dead getter pairs unlike Sheep and Wolf (no manual overrides needed)"],"recurring_patterns":["Class-level @Getter inconsistency continues — RestingSpot cleaner than Sheep/Wolf (no manual overrides), but Wolf and Grass/Water still inconsistent on implements Drawable","isOverlaping() checks otherObjects only — caller must separately check restingSpots; this asymmetry now causes the LOW-1 bug in createNewObject()","new Color(...) allocations inside draw() continue in Grass and Water (pre-existing, not introduced here)"]}
